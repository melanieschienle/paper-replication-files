#1 function for MSE and SC. 
#2 function with rolling window.
library(expm)
library(vars)
library(plyr)

VAR.reb<-function (x, p, type = "none", lag.max = 9, ic="AIC", exog=NULL) {
  x<-as.matrix(x)
  n <- nrow(x)
  k <- ncol(x)
  if (!is.null(lag.max)) {
    lag.max <- abs(as.integer(lag.max))
    ic <- paste(ic, "(n)", sep = "")
    p <- VARselect(y=x, lag.max = lag.max, type = type, season = NULL, 
                   exogen = exog)$selection[ic]
  }
  y <- t(x[(p + 1):n, ]) # entities in rows, obs in columns
  z0 <- t(x[n:1, ]) #change order, because we do loop backwards
  z <- matrix(1, nrow = k * p, ncol = 1) #Z; first column is constant
  for (i in n:(p + 1)) {
    m <- as.vector(z0[, (i - p + 1):i])# Zt; vector: (xt-1, xt-2,...,xt-p)
    z <- cbind(z, m)# 1st column is Zt vector for t=1, 2nd for t=2, ...
  }
  if (type == "none") 
    z <- z[, 2:(n - p + 1), drop = FALSE]
  if (type == "const") 
    z <- rbind(z[, 2:(n - p + 1)], matrix(1, nrow = 1, ncol = (n - 
                                                                 p)))
  if (type == "const+trend") 
    z <- rbind(z[, 2:(n - p + 1)], matrix(1, nrow = 1, ncol = (n - 
                                                                 p)), matrix((p + 1):n, ncol = (n - p)))
  if (!is.null(exog)){
    # lags of exogenous variable? here:not
    g<- t(exog[(p + 1):n, ])
    z<-rbind(z,g)
  }
  b <- tcrossprod(y, z) %*% solve(tcrossprod(z)) # [A_t-1 | A_t-2 | ...| A_t-p]
  rownames(b) <- colnames(x)
  #colnames(b) <- VAR.names(x, p, type)
  e <- y - b %*% z
  sigu <- tcrossprod(e)/((n - p) - ncol(b))
  zz <- tcrossprod(z)/(n - p)
  tem1 = (n - p)^(-1) * solve(zz) %x% sigu
  tem2 = sqrt(diag(tem1))
  tem3 = matrix(tem2, nrow = k, ncol = ncol(b))
  tmat = b/tem3
  
  if (type == "none") {
    J<- cbind(diag(k), matrix(0,ncol=k*(p-1),nrow=k))
    B<- rbind(b,cbind(diag(k*(p-1)),matrix(0,nrow=k*(p-1),ncol=(ncol(b)-k*(p-1)))))
  }
    if (type == "const") {
      J<- cbind(diag(k), matrix(0,ncol=k*(p-1)+1,nrow=k))
      B<- rbind(b,cbind(diag(k*(p-1)),matrix(0,nrow=k*(p-1),ncol=(k+1))),
                        c(rep(0,k*(p)),1))
    }
  #   if (type == "const+trend") {
  #     J<- cbind(diag(k), matrix(0,nrow=k*(p-1),ncol=(k+2)))
  #     B<- rbind(c(rep(0,k*p),1,1),b,
  #          cbind(diag(k*(p-1)),matrix(0,nrow=k*(p-1),ncol=(k+2))))
  #   }
  
  return(list(coef = b, B = B, resid = t(e), sigu = sigu, zzmat = zz, 
              zmat = z, tratio = tmat, J=J, p=p, datamat=rbind(y,z)))
}


predict.reb<-function (object, ..., n.ahead = 10, dumvar = NULL) {
  K <- nrow(object$coef)
  p <- object$p
  obs <- ncol(object$zmat)
  #type <- object$type
  #data.all <- object$datamat # datamat is the data + lagged data (=Z in Lütti) used for the estimation
  ynames <-rownames(object$coef) # y is the entire original data
  n.ahead <- as.integer(n.ahead)
  #Z <- t(object$zmat)
  Zdet<-NULL
  B <- object$coef
  if (!is.null(dumvar)) {
    Zdet <- as.matrix(dumvar)
  } else {Zdet<- NULL}
  Zy <- as.matrix(object$datamat[1:(K * (p + 1)),])#without const or trend
  forecast <- matrix(NA, ncol = K, nrow = n.ahead)#empty matrix
  lasty <- c(Zy[,ncol(Zy)])# last row of Zy
  for (i in 1:n.ahead) {
    lasty <- lasty[1:(K * p)]
    Z <- c(lasty, Zdet[i, ])
    forecast[i, ] <- B %*% Z
    temp <- forecast[i, ]
    lasty <- c(temp, lasty)
  }
  colnames(forecast) <- paste(ynames, ".fcst", sep = "")
  
  result <- forecast
  return(result)
}

f.FE<-function(model,data,n.ahead,exogen=NULL){ #data and exogen must be with [(i+Te):(i+Te+n.ahead-1)]
  temp1<-colnames(model$datamat)[ncol(model$datamat)]
  temp2<-match(temp1,rownames(data))
  obsdata<-data[(temp2+1):(temp2+n.ahead),]
  
  if (!(is.null(exogen))){
    pred<-predict.reb(model, n.ahead=n.ahead, dumvar=exogen)  
  } else {
    pred<-predict.reb(model, n.ahead=n.ahead)  
  }
  FE<- pred-obsdata
  #mse2<-array(apply(FE,1,function(x){x%o%x}),dim=c(ncol(data),ncol(data), n.ahead)) # %o% is outer product
  #result<-mse2[,,n.ahead]
  #mse<-FE[n.ahead,] %o% FE[n.ahead,]
  result<-FE[n.ahead,]
  return(result)
}

Phi.reb<- function(x,nstep=10){ # x is an object generated by VAR.reb()
  k<-nrow(x$coef)
  phi<-array(NA,dim=c(k,k,(nstep+1)))
  phi[,,1]<-diag(k)
  for (i in 1:nstep){
    phi[,,(i+1)]<- x$J %*% (x$B%^%i) %*% t(x$J)
  }
  return(phi)# array with dim (k x k x nstep+1)
}

# f.ytH<-function(model, n.ahead){
#   temp1<-colnames(model$datamat)[ncol(model$datamat)]
#   temp2<-match(temp1,rownames(data))
#   obsdata<-data[(temp2+1):(temp2+n.ahead),]
#   return(obsdata)
# }

f.VD <- function (data,n.ahead) {
  n<- nrow(data) # number of observations
  K<-ncol(data) # number of variables in y
  ynames<-colnames(data) # country names
  #rownames<-rownames(data)
  
  # 1. estimate VAR and save forecast error
  FE<-matrix(0,nrow=n,ncol=K)
#  obsdata<-matrix(0,nrow=n,ncol=K)
  # not possible to compute FE's for first Te + n.ahead-1 observations
  FE[1:(Te+n.ahead-1),]<-NA
#  obsdata[1:(Te+n.ahead-1),]<-NA
  sigu<-array(,dim=c(K,K,n)) # save Sigma_u
  sigu[,,1:(Te-1)]<-NA
#  A<-array(,dim=c(K,K*3,n)) # save coefficient matrix A
    
  for (i in 1:(n-Te+1-n.ahead)){
    model<-VAR.reb(data[i:(i+Te-1),], type = "none", lag.max = 3, ic="AIC",exog=NULL)
    FE[(i+Te+n.ahead-1),]<-unlist(f.FE(model,data,n.ahead=n.ahead,exogen=NULL))
    sigu[,,(i+Te-1)]<-model$sigu
#    obsdata[(i+Te+n.ahead-1),]<-f.ytH(model,n.ahead=n.ahead)
    
#     if(dim(model$coef)[2]!=dim(A)[2]) {
#       a<- cbind(model$coef, array(NA, dim=c(9, dim(A)[2]-dim(model$coef)[2])))
#     } else {
#       a<-model$coef
#     }
#     A[,,(i+Te-1)]<-a
  }
#  A[,,1:(Te-1)]<-NA
  
  # 2. estimate MSE
  MSE<-array(,dim=c(K,K,n))
  for (i in (Te+n.ahead):(n-Ts+1)){
    x<-FE[i:(i+Ts-1),]
    MSE[,,(i+Ts-1)]<-crossprod(x)/Ts
  }
#  sigsig<-sigu-MSE
#  yty<-array(,dim=c(K,K,n)) 
#  for (i in (Te+n.ahead):(n-Ts+1)){ 
#    x<-obsdata[i:(i+Ts-1),] 
#    yty[,,(i+Ts-1)]<-crossprod(x)/Ts 
#  } 
  
  # 3. estimate variance decomposition matrix
  S<-array(,dim=c(K,K,n))
  for(i in 1:K){
    for(j in 1:K){
      S[i,j,]<-(MSE[i,j,]^2)/(MSE[i,i,]*MSE[j,j,])
      #S[i,j,]<-(MSE[i,j,])/sqrt((MSE[i,i,]*MSE[j,j,]))
    }
  }
  Stilde<-array(,dim=c(K,K,n))
  for(i in (Te+n.ahead):(n-Ts+1)){
    sum<- rowSums(S[,,(i+Ts-1)]) # compute sum of each row
    Stilde2<-array(,dim=c(K,K))# for each row i, divide each element by sum[i]
    for(j in 1:K){
      Stilde2[j,]<-apply(t(as.matrix(S[j,,(i+Ts-1)])),2,function(x){x/sum[j]})
    }
    Stilde[,,(i+Ts-1)]<-Stilde2
  }
  colnames(S)<-rownames(S)<-ynames
  colnames(Stilde)<-rownames(Stilde)<-ynames
  #dimnames(S)[[3]]<-dimnames(Stilde)[[3]]<-rownames
  return(list(S=S,Stilde=Stilde,MSE=MSE,sigu=sigu))
}

f.VD.sf <- function (data,n.ahead) {
  n<- nrow(data) # number of observations
  K<-ncol(data) # number of variables in y
  ynames<-colnames(data) # country names
  
  # 1. estimate VAR and save forecast error
  FE<-matrix(0,nrow=n,ncol=K)
  # not possible to compute FE's for first Te + n.ahead-1 observations
  FE[1:(Te+n.ahead-1),]<-NA
  
  wrapper<-function(i){
    model<-VAR.reb(data[i:(i+Te-1),], type = "none", lag.max = 3, ic="AIC",exog=NULL)
    FE[(i+Te+n.ahead-1),]<-f.FE(model,data,n.ahead=n.ahead,exogen=NULL)
    return(FE)
  }
  ptm <- proc.time()
  FE.sf<-sfSapply(seq(1,(n-Te+1-n.ahead),1), wrapper)
  proc.time() - ptm
    
  # 2. estimate MSE
  MSE<-array(,dim=c(K,K,n))
  for (i in (Te+n.ahead):(n-Ts+1)){
    x<-FE[i:(i+Ts-1),]
    MSE[,,(i+Ts-1)]<-crossprod(x)/Ts
  }
    
  # 3. estimate variance decomposition matrix
  S<-array(,dim=c(K,K,n))
  for(i in 1:K){
    for(j in 1:K){
      S[i,j,]<-(MSE[i,j,]^2)/(MSE[i,i,]*MSE[j,j,])
      #S[i,j,]<-(MSE[i,j,])/sqrt((MSE[i,i,]*MSE[j,j,]))
    }
  }
  colnames(S)<-rownames(S)<-ynames
  return(list(S=S,MSE=MSE))
}

f.VDin <- function (data,n.ahead) {
  n<- nrow(data) # number of observations
  K<-ncol(data) # number of variables in y
  ynames<-colnames(data) # country names
  rownames<-rownames(data)
  
  D<-array(,dim=c(K,K,n))
  DD<-array(,dim=c(K,K,n))
  MSE<-array(,dim=c(K,K,n))
  colnames(D)<-rownames(D)<-colnames(DD)<-rownames(DD)<-colnames(MSE)<-rownames(MSE)<-ynames
  
  for (t in 1:(n-Te+1-n.ahead)){
    model<-VAR.reb(data[t:(t+Te-1),], type = "none", lag.max = 3, ic="AIC",exog=NULL)
    sigu<-model$sigu
    phi<-Phi.reb(model, nstep=n.ahead) 
    
    # numerator matrix#
    f1<- function(x) x%*%sigu # multiply phi by sigma for h=0,...,H.
    phisigma<- alply(phi, 3, f1)
    f2<- function(x) x^2 # take square of each element of matrix phisigma
    phisigma2<- lapply(phisigma, f2)
    numerator<- Reduce("+", phisigma2)# sum of phisigma2's for h=0,...H
    
    # denominator matrix #
    f3<- function(x) x%*%sigu%*%t(x) # multiply phi sigma phi-transposed for h=0,...,H
    phisigmaphi<- alply(phi, 3, f3)
    denominator<- Reduce("+", phisigmaphi) # sum of phisigmaphi's
    
    rm(f1, f2, f3, phisigma, phisigma2, phisigmaphi)
    
    # variance decomposition matrix #
    D2<-array(,dim=c(K,K))
    for(i in 1:K){
      for(j in 1:K){
        D2[i,j]<-numerator[i,j]/(denominator[i,i]*sigu[j,j])
      }
    }
    DD[,,(t-1+Te)]<-D2
    rm(numerator, denominator)
    
    # Dtilde2 #
    sum<- rowSums(D2) # compute sum of each row
    Dtilde2<-array(,dim=c(K,K))# for each row i, divide each element by sum[i]
    for(i in 1:K){
      Dtilde2[i,]<-apply(t(as.matrix(D2[i,])),2,function(x){x/sum[i]})
    }
    rm(sum)
    
    D[,,(t-1+Te)]<-Dtilde2
    
    # MSE #
    tMSE<-matrix(0,nrow=K, ncol= K)
    for (f in 1:n.ahead){
      tMSE<-tMSE+phi[,,f] %*% sigu %*% t(phi[,,f])
    }
    MSE[,,(t-1+Te)]<-tMSE
  }
  dimnames(D)[[3]]<-dimnames(DD)[[3]]<-rownames
  return(list(Dtilde=D,D=DD, MSE=MSE))
}

f.sums<-function(x){# x is an object generated by f.VD or f.VDin
  froms<-apply(x,3,function(x){rowSums(x)-diag(x)})
  tos<-apply(x,3,function(x){colSums(x)-diag(x)})
  nets<-tos-froms
  totals<-apply(tos,2,mean)
  return(list(froms=froms, tos=tos, nets=nets, totals=totals))
}




# #4.
# #i: VAR- cf 1
# #ii: GARCH(1,1) for each time series
# summary(garch(resid(rvar)[,1], order=c(1,1)))
# summary(garch(resid(eurvar)[,1], order=c(1,1)))
# summary(garch(resid(stxvar)[,1], order=c(1,1)))
# 
# summary(arma(resid(rvar)[,i], order=c(1,1)))
# ############### check if GARCh-coefficients are significant
